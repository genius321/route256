package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"route256/checkout/internal/pkg/checkout"
	"route256/checkout/internal/repository/schema"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"google.golang.org/protobuf/types/known/emptypb"
)

// RepositoryMock implements service.Repository
type RepositoryMock struct {
	t minimock.Tester

	funcAddToCart          func(ctx context.Context, req *checkout.AddToCartRequest) (ep1 *emptypb.Empty, err error)
	inspectFuncAddToCart   func(ctx context.Context, req *checkout.AddToCartRequest)
	afterAddToCartCounter  uint64
	beforeAddToCartCounter uint64
	AddToCartMock          mRepositoryMockAddToCart

	funcDeleteAllFromCart          func(ctx context.Context, req *checkout.DeleteFromCartRequest) (ep1 *emptypb.Empty, err error)
	inspectFuncDeleteAllFromCart   func(ctx context.Context, req *checkout.DeleteFromCartRequest)
	afterDeleteAllFromCartCounter  uint64
	beforeDeleteAllFromCartCounter uint64
	DeleteAllFromCartMock          mRepositoryMockDeleteAllFromCart

	funcDeleteFromCart          func(ctx context.Context, req *checkout.DeleteFromCartRequest) (ep1 *emptypb.Empty, err error)
	inspectFuncDeleteFromCart   func(ctx context.Context, req *checkout.DeleteFromCartRequest)
	afterDeleteFromCartCounter  uint64
	beforeDeleteFromCartCounter uint64
	DeleteFromCartMock          mRepositoryMockDeleteFromCart

	funcListCart          func(ctx context.Context, req *checkout.ListCartRequest) (ipa1 []*schema.Item, err error)
	inspectFuncListCart   func(ctx context.Context, req *checkout.ListCartRequest)
	afterListCartCounter  uint64
	beforeListCartCounter uint64
	ListCartMock          mRepositoryMockListCart

	funcSubFromCart          func(ctx context.Context, userId int64, sku int64, count int64) (err error)
	inspectFuncSubFromCart   func(ctx context.Context, userId int64, sku int64, count int64)
	afterSubFromCartCounter  uint64
	beforeSubFromCartCounter uint64
	SubFromCartMock          mRepositoryMockSubFromCart

	funcTakeCountSkuUserFromCart          func(ctx context.Context, userId int64, sku int64) (i1 int64, err error)
	inspectFuncTakeCountSkuUserFromCart   func(ctx context.Context, userId int64, sku int64)
	afterTakeCountSkuUserFromCartCounter  uint64
	beforeTakeCountSkuUserFromCartCounter uint64
	TakeCountSkuUserFromCartMock          mRepositoryMockTakeCountSkuUserFromCart
}

// NewRepositoryMock returns a mock for service.Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddToCartMock = mRepositoryMockAddToCart{mock: m}
	m.AddToCartMock.callArgs = []*RepositoryMockAddToCartParams{}

	m.DeleteAllFromCartMock = mRepositoryMockDeleteAllFromCart{mock: m}
	m.DeleteAllFromCartMock.callArgs = []*RepositoryMockDeleteAllFromCartParams{}

	m.DeleteFromCartMock = mRepositoryMockDeleteFromCart{mock: m}
	m.DeleteFromCartMock.callArgs = []*RepositoryMockDeleteFromCartParams{}

	m.ListCartMock = mRepositoryMockListCart{mock: m}
	m.ListCartMock.callArgs = []*RepositoryMockListCartParams{}

	m.SubFromCartMock = mRepositoryMockSubFromCart{mock: m}
	m.SubFromCartMock.callArgs = []*RepositoryMockSubFromCartParams{}

	m.TakeCountSkuUserFromCartMock = mRepositoryMockTakeCountSkuUserFromCart{mock: m}
	m.TakeCountSkuUserFromCartMock.callArgs = []*RepositoryMockTakeCountSkuUserFromCartParams{}

	return m
}

type mRepositoryMockAddToCart struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockAddToCartExpectation
	expectations       []*RepositoryMockAddToCartExpectation

	callArgs []*RepositoryMockAddToCartParams
	mutex    sync.RWMutex
}

// RepositoryMockAddToCartExpectation specifies expectation struct of the Repository.AddToCart
type RepositoryMockAddToCartExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockAddToCartParams
	results *RepositoryMockAddToCartResults
	Counter uint64
}

// RepositoryMockAddToCartParams contains parameters of the Repository.AddToCart
type RepositoryMockAddToCartParams struct {
	ctx context.Context
	req *checkout.AddToCartRequest
}

// RepositoryMockAddToCartResults contains results of the Repository.AddToCart
type RepositoryMockAddToCartResults struct {
	ep1 *emptypb.Empty
	err error
}

// Expect sets up expected params for Repository.AddToCart
func (mmAddToCart *mRepositoryMockAddToCart) Expect(ctx context.Context, req *checkout.AddToCartRequest) *mRepositoryMockAddToCart {
	if mmAddToCart.mock.funcAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("RepositoryMock.AddToCart mock is already set by Set")
	}

	if mmAddToCart.defaultExpectation == nil {
		mmAddToCart.defaultExpectation = &RepositoryMockAddToCartExpectation{}
	}

	mmAddToCart.defaultExpectation.params = &RepositoryMockAddToCartParams{ctx, req}
	for _, e := range mmAddToCart.expectations {
		if minimock.Equal(e.params, mmAddToCart.defaultExpectation.params) {
			mmAddToCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddToCart.defaultExpectation.params)
		}
	}

	return mmAddToCart
}

// Inspect accepts an inspector function that has same arguments as the Repository.AddToCart
func (mmAddToCart *mRepositoryMockAddToCart) Inspect(f func(ctx context.Context, req *checkout.AddToCartRequest)) *mRepositoryMockAddToCart {
	if mmAddToCart.mock.inspectFuncAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("Inspect function is already set for RepositoryMock.AddToCart")
	}

	mmAddToCart.mock.inspectFuncAddToCart = f

	return mmAddToCart
}

// Return sets up results that will be returned by Repository.AddToCart
func (mmAddToCart *mRepositoryMockAddToCart) Return(ep1 *emptypb.Empty, err error) *RepositoryMock {
	if mmAddToCart.mock.funcAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("RepositoryMock.AddToCart mock is already set by Set")
	}

	if mmAddToCart.defaultExpectation == nil {
		mmAddToCart.defaultExpectation = &RepositoryMockAddToCartExpectation{mock: mmAddToCart.mock}
	}
	mmAddToCart.defaultExpectation.results = &RepositoryMockAddToCartResults{ep1, err}
	return mmAddToCart.mock
}

// Set uses given function f to mock the Repository.AddToCart method
func (mmAddToCart *mRepositoryMockAddToCart) Set(f func(ctx context.Context, req *checkout.AddToCartRequest) (ep1 *emptypb.Empty, err error)) *RepositoryMock {
	if mmAddToCart.defaultExpectation != nil {
		mmAddToCart.mock.t.Fatalf("Default expectation is already set for the Repository.AddToCart method")
	}

	if len(mmAddToCart.expectations) > 0 {
		mmAddToCart.mock.t.Fatalf("Some expectations are already set for the Repository.AddToCart method")
	}

	mmAddToCart.mock.funcAddToCart = f
	return mmAddToCart.mock
}

// When sets expectation for the Repository.AddToCart which will trigger the result defined by the following
// Then helper
func (mmAddToCart *mRepositoryMockAddToCart) When(ctx context.Context, req *checkout.AddToCartRequest) *RepositoryMockAddToCartExpectation {
	if mmAddToCart.mock.funcAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("RepositoryMock.AddToCart mock is already set by Set")
	}

	expectation := &RepositoryMockAddToCartExpectation{
		mock:   mmAddToCart.mock,
		params: &RepositoryMockAddToCartParams{ctx, req},
	}
	mmAddToCart.expectations = append(mmAddToCart.expectations, expectation)
	return expectation
}

// Then sets up Repository.AddToCart return parameters for the expectation previously defined by the When method
func (e *RepositoryMockAddToCartExpectation) Then(ep1 *emptypb.Empty, err error) *RepositoryMock {
	e.results = &RepositoryMockAddToCartResults{ep1, err}
	return e.mock
}

// AddToCart implements service.Repository
func (mmAddToCart *RepositoryMock) AddToCart(ctx context.Context, req *checkout.AddToCartRequest) (ep1 *emptypb.Empty, err error) {
	mm_atomic.AddUint64(&mmAddToCart.beforeAddToCartCounter, 1)
	defer mm_atomic.AddUint64(&mmAddToCart.afterAddToCartCounter, 1)

	if mmAddToCart.inspectFuncAddToCart != nil {
		mmAddToCart.inspectFuncAddToCart(ctx, req)
	}

	mm_params := &RepositoryMockAddToCartParams{ctx, req}

	// Record call args
	mmAddToCart.AddToCartMock.mutex.Lock()
	mmAddToCart.AddToCartMock.callArgs = append(mmAddToCart.AddToCartMock.callArgs, mm_params)
	mmAddToCart.AddToCartMock.mutex.Unlock()

	for _, e := range mmAddToCart.AddToCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ep1, e.results.err
		}
	}

	if mmAddToCart.AddToCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddToCart.AddToCartMock.defaultExpectation.Counter, 1)
		mm_want := mmAddToCart.AddToCartMock.defaultExpectation.params
		mm_got := RepositoryMockAddToCartParams{ctx, req}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddToCart.t.Errorf("RepositoryMock.AddToCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddToCart.AddToCartMock.defaultExpectation.results
		if mm_results == nil {
			mmAddToCart.t.Fatal("No results are set for the RepositoryMock.AddToCart")
		}
		return (*mm_results).ep1, (*mm_results).err
	}
	if mmAddToCart.funcAddToCart != nil {
		return mmAddToCart.funcAddToCart(ctx, req)
	}
	mmAddToCart.t.Fatalf("Unexpected call to RepositoryMock.AddToCart. %v %v", ctx, req)
	return
}

// AddToCartAfterCounter returns a count of finished RepositoryMock.AddToCart invocations
func (mmAddToCart *RepositoryMock) AddToCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddToCart.afterAddToCartCounter)
}

// AddToCartBeforeCounter returns a count of RepositoryMock.AddToCart invocations
func (mmAddToCart *RepositoryMock) AddToCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddToCart.beforeAddToCartCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.AddToCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddToCart *mRepositoryMockAddToCart) Calls() []*RepositoryMockAddToCartParams {
	mmAddToCart.mutex.RLock()

	argCopy := make([]*RepositoryMockAddToCartParams, len(mmAddToCart.callArgs))
	copy(argCopy, mmAddToCart.callArgs)

	mmAddToCart.mutex.RUnlock()

	return argCopy
}

// MinimockAddToCartDone returns true if the count of the AddToCart invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockAddToCartDone() bool {
	for _, e := range m.AddToCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddToCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddToCart != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddToCartInspect logs each unmet expectation
func (m *RepositoryMock) MinimockAddToCartInspect() {
	for _, e := range m.AddToCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.AddToCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddToCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		if m.AddToCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.AddToCart")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.AddToCart with params: %#v", *m.AddToCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddToCart != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.AddToCart")
	}
}

type mRepositoryMockDeleteAllFromCart struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteAllFromCartExpectation
	expectations       []*RepositoryMockDeleteAllFromCartExpectation

	callArgs []*RepositoryMockDeleteAllFromCartParams
	mutex    sync.RWMutex
}

// RepositoryMockDeleteAllFromCartExpectation specifies expectation struct of the Repository.DeleteAllFromCart
type RepositoryMockDeleteAllFromCartExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockDeleteAllFromCartParams
	results *RepositoryMockDeleteAllFromCartResults
	Counter uint64
}

// RepositoryMockDeleteAllFromCartParams contains parameters of the Repository.DeleteAllFromCart
type RepositoryMockDeleteAllFromCartParams struct {
	ctx context.Context
	req *checkout.DeleteFromCartRequest
}

// RepositoryMockDeleteAllFromCartResults contains results of the Repository.DeleteAllFromCart
type RepositoryMockDeleteAllFromCartResults struct {
	ep1 *emptypb.Empty
	err error
}

// Expect sets up expected params for Repository.DeleteAllFromCart
func (mmDeleteAllFromCart *mRepositoryMockDeleteAllFromCart) Expect(ctx context.Context, req *checkout.DeleteFromCartRequest) *mRepositoryMockDeleteAllFromCart {
	if mmDeleteAllFromCart.mock.funcDeleteAllFromCart != nil {
		mmDeleteAllFromCart.mock.t.Fatalf("RepositoryMock.DeleteAllFromCart mock is already set by Set")
	}

	if mmDeleteAllFromCart.defaultExpectation == nil {
		mmDeleteAllFromCart.defaultExpectation = &RepositoryMockDeleteAllFromCartExpectation{}
	}

	mmDeleteAllFromCart.defaultExpectation.params = &RepositoryMockDeleteAllFromCartParams{ctx, req}
	for _, e := range mmDeleteAllFromCart.expectations {
		if minimock.Equal(e.params, mmDeleteAllFromCart.defaultExpectation.params) {
			mmDeleteAllFromCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteAllFromCart.defaultExpectation.params)
		}
	}

	return mmDeleteAllFromCart
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteAllFromCart
func (mmDeleteAllFromCart *mRepositoryMockDeleteAllFromCart) Inspect(f func(ctx context.Context, req *checkout.DeleteFromCartRequest)) *mRepositoryMockDeleteAllFromCart {
	if mmDeleteAllFromCart.mock.inspectFuncDeleteAllFromCart != nil {
		mmDeleteAllFromCart.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteAllFromCart")
	}

	mmDeleteAllFromCart.mock.inspectFuncDeleteAllFromCart = f

	return mmDeleteAllFromCart
}

// Return sets up results that will be returned by Repository.DeleteAllFromCart
func (mmDeleteAllFromCart *mRepositoryMockDeleteAllFromCart) Return(ep1 *emptypb.Empty, err error) *RepositoryMock {
	if mmDeleteAllFromCart.mock.funcDeleteAllFromCart != nil {
		mmDeleteAllFromCart.mock.t.Fatalf("RepositoryMock.DeleteAllFromCart mock is already set by Set")
	}

	if mmDeleteAllFromCart.defaultExpectation == nil {
		mmDeleteAllFromCart.defaultExpectation = &RepositoryMockDeleteAllFromCartExpectation{mock: mmDeleteAllFromCart.mock}
	}
	mmDeleteAllFromCart.defaultExpectation.results = &RepositoryMockDeleteAllFromCartResults{ep1, err}
	return mmDeleteAllFromCart.mock
}

// Set uses given function f to mock the Repository.DeleteAllFromCart method
func (mmDeleteAllFromCart *mRepositoryMockDeleteAllFromCart) Set(f func(ctx context.Context, req *checkout.DeleteFromCartRequest) (ep1 *emptypb.Empty, err error)) *RepositoryMock {
	if mmDeleteAllFromCart.defaultExpectation != nil {
		mmDeleteAllFromCart.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteAllFromCart method")
	}

	if len(mmDeleteAllFromCart.expectations) > 0 {
		mmDeleteAllFromCart.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteAllFromCart method")
	}

	mmDeleteAllFromCart.mock.funcDeleteAllFromCart = f
	return mmDeleteAllFromCart.mock
}

// When sets expectation for the Repository.DeleteAllFromCart which will trigger the result defined by the following
// Then helper
func (mmDeleteAllFromCart *mRepositoryMockDeleteAllFromCart) When(ctx context.Context, req *checkout.DeleteFromCartRequest) *RepositoryMockDeleteAllFromCartExpectation {
	if mmDeleteAllFromCart.mock.funcDeleteAllFromCart != nil {
		mmDeleteAllFromCart.mock.t.Fatalf("RepositoryMock.DeleteAllFromCart mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteAllFromCartExpectation{
		mock:   mmDeleteAllFromCart.mock,
		params: &RepositoryMockDeleteAllFromCartParams{ctx, req},
	}
	mmDeleteAllFromCart.expectations = append(mmDeleteAllFromCart.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteAllFromCart return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteAllFromCartExpectation) Then(ep1 *emptypb.Empty, err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteAllFromCartResults{ep1, err}
	return e.mock
}

// DeleteAllFromCart implements service.Repository
func (mmDeleteAllFromCart *RepositoryMock) DeleteAllFromCart(ctx context.Context, req *checkout.DeleteFromCartRequest) (ep1 *emptypb.Empty, err error) {
	mm_atomic.AddUint64(&mmDeleteAllFromCart.beforeDeleteAllFromCartCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteAllFromCart.afterDeleteAllFromCartCounter, 1)

	if mmDeleteAllFromCart.inspectFuncDeleteAllFromCart != nil {
		mmDeleteAllFromCart.inspectFuncDeleteAllFromCart(ctx, req)
	}

	mm_params := &RepositoryMockDeleteAllFromCartParams{ctx, req}

	// Record call args
	mmDeleteAllFromCart.DeleteAllFromCartMock.mutex.Lock()
	mmDeleteAllFromCart.DeleteAllFromCartMock.callArgs = append(mmDeleteAllFromCart.DeleteAllFromCartMock.callArgs, mm_params)
	mmDeleteAllFromCart.DeleteAllFromCartMock.mutex.Unlock()

	for _, e := range mmDeleteAllFromCart.DeleteAllFromCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ep1, e.results.err
		}
	}

	if mmDeleteAllFromCart.DeleteAllFromCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteAllFromCart.DeleteAllFromCartMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteAllFromCart.DeleteAllFromCartMock.defaultExpectation.params
		mm_got := RepositoryMockDeleteAllFromCartParams{ctx, req}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteAllFromCart.t.Errorf("RepositoryMock.DeleteAllFromCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteAllFromCart.DeleteAllFromCartMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteAllFromCart.t.Fatal("No results are set for the RepositoryMock.DeleteAllFromCart")
		}
		return (*mm_results).ep1, (*mm_results).err
	}
	if mmDeleteAllFromCart.funcDeleteAllFromCart != nil {
		return mmDeleteAllFromCart.funcDeleteAllFromCart(ctx, req)
	}
	mmDeleteAllFromCart.t.Fatalf("Unexpected call to RepositoryMock.DeleteAllFromCart. %v %v", ctx, req)
	return
}

// DeleteAllFromCartAfterCounter returns a count of finished RepositoryMock.DeleteAllFromCart invocations
func (mmDeleteAllFromCart *RepositoryMock) DeleteAllFromCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAllFromCart.afterDeleteAllFromCartCounter)
}

// DeleteAllFromCartBeforeCounter returns a count of RepositoryMock.DeleteAllFromCart invocations
func (mmDeleteAllFromCart *RepositoryMock) DeleteAllFromCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAllFromCart.beforeDeleteAllFromCartCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteAllFromCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteAllFromCart *mRepositoryMockDeleteAllFromCart) Calls() []*RepositoryMockDeleteAllFromCartParams {
	mmDeleteAllFromCart.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteAllFromCartParams, len(mmDeleteAllFromCart.callArgs))
	copy(argCopy, mmDeleteAllFromCart.callArgs)

	mmDeleteAllFromCart.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteAllFromCartDone returns true if the count of the DeleteAllFromCart invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteAllFromCartDone() bool {
	for _, e := range m.DeleteAllFromCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteAllFromCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteAllFromCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteAllFromCart != nil && mm_atomic.LoadUint64(&m.afterDeleteAllFromCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteAllFromCartInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteAllFromCartInspect() {
	for _, e := range m.DeleteAllFromCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteAllFromCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteAllFromCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteAllFromCartCounter) < 1 {
		if m.DeleteAllFromCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.DeleteAllFromCart")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteAllFromCart with params: %#v", *m.DeleteAllFromCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteAllFromCart != nil && mm_atomic.LoadUint64(&m.afterDeleteAllFromCartCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.DeleteAllFromCart")
	}
}

type mRepositoryMockDeleteFromCart struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteFromCartExpectation
	expectations       []*RepositoryMockDeleteFromCartExpectation

	callArgs []*RepositoryMockDeleteFromCartParams
	mutex    sync.RWMutex
}

// RepositoryMockDeleteFromCartExpectation specifies expectation struct of the Repository.DeleteFromCart
type RepositoryMockDeleteFromCartExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockDeleteFromCartParams
	results *RepositoryMockDeleteFromCartResults
	Counter uint64
}

// RepositoryMockDeleteFromCartParams contains parameters of the Repository.DeleteFromCart
type RepositoryMockDeleteFromCartParams struct {
	ctx context.Context
	req *checkout.DeleteFromCartRequest
}

// RepositoryMockDeleteFromCartResults contains results of the Repository.DeleteFromCart
type RepositoryMockDeleteFromCartResults struct {
	ep1 *emptypb.Empty
	err error
}

// Expect sets up expected params for Repository.DeleteFromCart
func (mmDeleteFromCart *mRepositoryMockDeleteFromCart) Expect(ctx context.Context, req *checkout.DeleteFromCartRequest) *mRepositoryMockDeleteFromCart {
	if mmDeleteFromCart.mock.funcDeleteFromCart != nil {
		mmDeleteFromCart.mock.t.Fatalf("RepositoryMock.DeleteFromCart mock is already set by Set")
	}

	if mmDeleteFromCart.defaultExpectation == nil {
		mmDeleteFromCart.defaultExpectation = &RepositoryMockDeleteFromCartExpectation{}
	}

	mmDeleteFromCart.defaultExpectation.params = &RepositoryMockDeleteFromCartParams{ctx, req}
	for _, e := range mmDeleteFromCart.expectations {
		if minimock.Equal(e.params, mmDeleteFromCart.defaultExpectation.params) {
			mmDeleteFromCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteFromCart.defaultExpectation.params)
		}
	}

	return mmDeleteFromCart
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteFromCart
func (mmDeleteFromCart *mRepositoryMockDeleteFromCart) Inspect(f func(ctx context.Context, req *checkout.DeleteFromCartRequest)) *mRepositoryMockDeleteFromCart {
	if mmDeleteFromCart.mock.inspectFuncDeleteFromCart != nil {
		mmDeleteFromCart.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteFromCart")
	}

	mmDeleteFromCart.mock.inspectFuncDeleteFromCart = f

	return mmDeleteFromCart
}

// Return sets up results that will be returned by Repository.DeleteFromCart
func (mmDeleteFromCart *mRepositoryMockDeleteFromCart) Return(ep1 *emptypb.Empty, err error) *RepositoryMock {
	if mmDeleteFromCart.mock.funcDeleteFromCart != nil {
		mmDeleteFromCart.mock.t.Fatalf("RepositoryMock.DeleteFromCart mock is already set by Set")
	}

	if mmDeleteFromCart.defaultExpectation == nil {
		mmDeleteFromCart.defaultExpectation = &RepositoryMockDeleteFromCartExpectation{mock: mmDeleteFromCart.mock}
	}
	mmDeleteFromCart.defaultExpectation.results = &RepositoryMockDeleteFromCartResults{ep1, err}
	return mmDeleteFromCart.mock
}

// Set uses given function f to mock the Repository.DeleteFromCart method
func (mmDeleteFromCart *mRepositoryMockDeleteFromCart) Set(f func(ctx context.Context, req *checkout.DeleteFromCartRequest) (ep1 *emptypb.Empty, err error)) *RepositoryMock {
	if mmDeleteFromCart.defaultExpectation != nil {
		mmDeleteFromCart.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteFromCart method")
	}

	if len(mmDeleteFromCart.expectations) > 0 {
		mmDeleteFromCart.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteFromCart method")
	}

	mmDeleteFromCart.mock.funcDeleteFromCart = f
	return mmDeleteFromCart.mock
}

// When sets expectation for the Repository.DeleteFromCart which will trigger the result defined by the following
// Then helper
func (mmDeleteFromCart *mRepositoryMockDeleteFromCart) When(ctx context.Context, req *checkout.DeleteFromCartRequest) *RepositoryMockDeleteFromCartExpectation {
	if mmDeleteFromCart.mock.funcDeleteFromCart != nil {
		mmDeleteFromCart.mock.t.Fatalf("RepositoryMock.DeleteFromCart mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteFromCartExpectation{
		mock:   mmDeleteFromCart.mock,
		params: &RepositoryMockDeleteFromCartParams{ctx, req},
	}
	mmDeleteFromCart.expectations = append(mmDeleteFromCart.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteFromCart return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteFromCartExpectation) Then(ep1 *emptypb.Empty, err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteFromCartResults{ep1, err}
	return e.mock
}

// DeleteFromCart implements service.Repository
func (mmDeleteFromCart *RepositoryMock) DeleteFromCart(ctx context.Context, req *checkout.DeleteFromCartRequest) (ep1 *emptypb.Empty, err error) {
	mm_atomic.AddUint64(&mmDeleteFromCart.beforeDeleteFromCartCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteFromCart.afterDeleteFromCartCounter, 1)

	if mmDeleteFromCart.inspectFuncDeleteFromCart != nil {
		mmDeleteFromCart.inspectFuncDeleteFromCart(ctx, req)
	}

	mm_params := &RepositoryMockDeleteFromCartParams{ctx, req}

	// Record call args
	mmDeleteFromCart.DeleteFromCartMock.mutex.Lock()
	mmDeleteFromCart.DeleteFromCartMock.callArgs = append(mmDeleteFromCart.DeleteFromCartMock.callArgs, mm_params)
	mmDeleteFromCart.DeleteFromCartMock.mutex.Unlock()

	for _, e := range mmDeleteFromCart.DeleteFromCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ep1, e.results.err
		}
	}

	if mmDeleteFromCart.DeleteFromCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteFromCart.DeleteFromCartMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteFromCart.DeleteFromCartMock.defaultExpectation.params
		mm_got := RepositoryMockDeleteFromCartParams{ctx, req}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteFromCart.t.Errorf("RepositoryMock.DeleteFromCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteFromCart.DeleteFromCartMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteFromCart.t.Fatal("No results are set for the RepositoryMock.DeleteFromCart")
		}
		return (*mm_results).ep1, (*mm_results).err
	}
	if mmDeleteFromCart.funcDeleteFromCart != nil {
		return mmDeleteFromCart.funcDeleteFromCart(ctx, req)
	}
	mmDeleteFromCart.t.Fatalf("Unexpected call to RepositoryMock.DeleteFromCart. %v %v", ctx, req)
	return
}

// DeleteFromCartAfterCounter returns a count of finished RepositoryMock.DeleteFromCart invocations
func (mmDeleteFromCart *RepositoryMock) DeleteFromCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFromCart.afterDeleteFromCartCounter)
}

// DeleteFromCartBeforeCounter returns a count of RepositoryMock.DeleteFromCart invocations
func (mmDeleteFromCart *RepositoryMock) DeleteFromCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFromCart.beforeDeleteFromCartCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteFromCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteFromCart *mRepositoryMockDeleteFromCart) Calls() []*RepositoryMockDeleteFromCartParams {
	mmDeleteFromCart.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteFromCartParams, len(mmDeleteFromCart.callArgs))
	copy(argCopy, mmDeleteFromCart.callArgs)

	mmDeleteFromCart.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteFromCartDone returns true if the count of the DeleteFromCart invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteFromCartDone() bool {
	for _, e := range m.DeleteFromCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteFromCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteFromCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteFromCart != nil && mm_atomic.LoadUint64(&m.afterDeleteFromCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteFromCartInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteFromCartInspect() {
	for _, e := range m.DeleteFromCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteFromCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteFromCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteFromCartCounter) < 1 {
		if m.DeleteFromCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.DeleteFromCart")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteFromCart with params: %#v", *m.DeleteFromCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteFromCart != nil && mm_atomic.LoadUint64(&m.afterDeleteFromCartCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.DeleteFromCart")
	}
}

type mRepositoryMockListCart struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListCartExpectation
	expectations       []*RepositoryMockListCartExpectation

	callArgs []*RepositoryMockListCartParams
	mutex    sync.RWMutex
}

// RepositoryMockListCartExpectation specifies expectation struct of the Repository.ListCart
type RepositoryMockListCartExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockListCartParams
	results *RepositoryMockListCartResults
	Counter uint64
}

// RepositoryMockListCartParams contains parameters of the Repository.ListCart
type RepositoryMockListCartParams struct {
	ctx context.Context
	req *checkout.ListCartRequest
}

// RepositoryMockListCartResults contains results of the Repository.ListCart
type RepositoryMockListCartResults struct {
	ipa1 []*schema.Item
	err  error
}

// Expect sets up expected params for Repository.ListCart
func (mmListCart *mRepositoryMockListCart) Expect(ctx context.Context, req *checkout.ListCartRequest) *mRepositoryMockListCart {
	if mmListCart.mock.funcListCart != nil {
		mmListCart.mock.t.Fatalf("RepositoryMock.ListCart mock is already set by Set")
	}

	if mmListCart.defaultExpectation == nil {
		mmListCart.defaultExpectation = &RepositoryMockListCartExpectation{}
	}

	mmListCart.defaultExpectation.params = &RepositoryMockListCartParams{ctx, req}
	for _, e := range mmListCart.expectations {
		if minimock.Equal(e.params, mmListCart.defaultExpectation.params) {
			mmListCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListCart.defaultExpectation.params)
		}
	}

	return mmListCart
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListCart
func (mmListCart *mRepositoryMockListCart) Inspect(f func(ctx context.Context, req *checkout.ListCartRequest)) *mRepositoryMockListCart {
	if mmListCart.mock.inspectFuncListCart != nil {
		mmListCart.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListCart")
	}

	mmListCart.mock.inspectFuncListCart = f

	return mmListCart
}

// Return sets up results that will be returned by Repository.ListCart
func (mmListCart *mRepositoryMockListCart) Return(ipa1 []*schema.Item, err error) *RepositoryMock {
	if mmListCart.mock.funcListCart != nil {
		mmListCart.mock.t.Fatalf("RepositoryMock.ListCart mock is already set by Set")
	}

	if mmListCart.defaultExpectation == nil {
		mmListCart.defaultExpectation = &RepositoryMockListCartExpectation{mock: mmListCart.mock}
	}
	mmListCart.defaultExpectation.results = &RepositoryMockListCartResults{ipa1, err}
	return mmListCart.mock
}

// Set uses given function f to mock the Repository.ListCart method
func (mmListCart *mRepositoryMockListCart) Set(f func(ctx context.Context, req *checkout.ListCartRequest) (ipa1 []*schema.Item, err error)) *RepositoryMock {
	if mmListCart.defaultExpectation != nil {
		mmListCart.mock.t.Fatalf("Default expectation is already set for the Repository.ListCart method")
	}

	if len(mmListCart.expectations) > 0 {
		mmListCart.mock.t.Fatalf("Some expectations are already set for the Repository.ListCart method")
	}

	mmListCart.mock.funcListCart = f
	return mmListCart.mock
}

// When sets expectation for the Repository.ListCart which will trigger the result defined by the following
// Then helper
func (mmListCart *mRepositoryMockListCart) When(ctx context.Context, req *checkout.ListCartRequest) *RepositoryMockListCartExpectation {
	if mmListCart.mock.funcListCart != nil {
		mmListCart.mock.t.Fatalf("RepositoryMock.ListCart mock is already set by Set")
	}

	expectation := &RepositoryMockListCartExpectation{
		mock:   mmListCart.mock,
		params: &RepositoryMockListCartParams{ctx, req},
	}
	mmListCart.expectations = append(mmListCart.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListCart return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListCartExpectation) Then(ipa1 []*schema.Item, err error) *RepositoryMock {
	e.results = &RepositoryMockListCartResults{ipa1, err}
	return e.mock
}

// ListCart implements service.Repository
func (mmListCart *RepositoryMock) ListCart(ctx context.Context, req *checkout.ListCartRequest) (ipa1 []*schema.Item, err error) {
	mm_atomic.AddUint64(&mmListCart.beforeListCartCounter, 1)
	defer mm_atomic.AddUint64(&mmListCart.afterListCartCounter, 1)

	if mmListCart.inspectFuncListCart != nil {
		mmListCart.inspectFuncListCart(ctx, req)
	}

	mm_params := &RepositoryMockListCartParams{ctx, req}

	// Record call args
	mmListCart.ListCartMock.mutex.Lock()
	mmListCart.ListCartMock.callArgs = append(mmListCart.ListCartMock.callArgs, mm_params)
	mmListCart.ListCartMock.mutex.Unlock()

	for _, e := range mmListCart.ListCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ipa1, e.results.err
		}
	}

	if mmListCart.ListCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListCart.ListCartMock.defaultExpectation.Counter, 1)
		mm_want := mmListCart.ListCartMock.defaultExpectation.params
		mm_got := RepositoryMockListCartParams{ctx, req}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListCart.t.Errorf("RepositoryMock.ListCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListCart.ListCartMock.defaultExpectation.results
		if mm_results == nil {
			mmListCart.t.Fatal("No results are set for the RepositoryMock.ListCart")
		}
		return (*mm_results).ipa1, (*mm_results).err
	}
	if mmListCart.funcListCart != nil {
		return mmListCart.funcListCart(ctx, req)
	}
	mmListCart.t.Fatalf("Unexpected call to RepositoryMock.ListCart. %v %v", ctx, req)
	return
}

// ListCartAfterCounter returns a count of finished RepositoryMock.ListCart invocations
func (mmListCart *RepositoryMock) ListCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCart.afterListCartCounter)
}

// ListCartBeforeCounter returns a count of RepositoryMock.ListCart invocations
func (mmListCart *RepositoryMock) ListCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCart.beforeListCartCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListCart *mRepositoryMockListCart) Calls() []*RepositoryMockListCartParams {
	mmListCart.mutex.RLock()

	argCopy := make([]*RepositoryMockListCartParams, len(mmListCart.callArgs))
	copy(argCopy, mmListCart.callArgs)

	mmListCart.mutex.RUnlock()

	return argCopy
}

// MinimockListCartDone returns true if the count of the ListCart invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListCartDone() bool {
	for _, e := range m.ListCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListCart != nil && mm_atomic.LoadUint64(&m.afterListCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockListCartInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListCartInspect() {
	for _, e := range m.ListCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListCartCounter) < 1 {
		if m.ListCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.ListCart")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListCart with params: %#v", *m.ListCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListCart != nil && mm_atomic.LoadUint64(&m.afterListCartCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.ListCart")
	}
}

type mRepositoryMockSubFromCart struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockSubFromCartExpectation
	expectations       []*RepositoryMockSubFromCartExpectation

	callArgs []*RepositoryMockSubFromCartParams
	mutex    sync.RWMutex
}

// RepositoryMockSubFromCartExpectation specifies expectation struct of the Repository.SubFromCart
type RepositoryMockSubFromCartExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockSubFromCartParams
	results *RepositoryMockSubFromCartResults
	Counter uint64
}

// RepositoryMockSubFromCartParams contains parameters of the Repository.SubFromCart
type RepositoryMockSubFromCartParams struct {
	ctx    context.Context
	userId int64
	sku    int64
	count  int64
}

// RepositoryMockSubFromCartResults contains results of the Repository.SubFromCart
type RepositoryMockSubFromCartResults struct {
	err error
}

// Expect sets up expected params for Repository.SubFromCart
func (mmSubFromCart *mRepositoryMockSubFromCart) Expect(ctx context.Context, userId int64, sku int64, count int64) *mRepositoryMockSubFromCart {
	if mmSubFromCart.mock.funcSubFromCart != nil {
		mmSubFromCart.mock.t.Fatalf("RepositoryMock.SubFromCart mock is already set by Set")
	}

	if mmSubFromCart.defaultExpectation == nil {
		mmSubFromCart.defaultExpectation = &RepositoryMockSubFromCartExpectation{}
	}

	mmSubFromCart.defaultExpectation.params = &RepositoryMockSubFromCartParams{ctx, userId, sku, count}
	for _, e := range mmSubFromCart.expectations {
		if minimock.Equal(e.params, mmSubFromCart.defaultExpectation.params) {
			mmSubFromCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSubFromCart.defaultExpectation.params)
		}
	}

	return mmSubFromCart
}

// Inspect accepts an inspector function that has same arguments as the Repository.SubFromCart
func (mmSubFromCart *mRepositoryMockSubFromCart) Inspect(f func(ctx context.Context, userId int64, sku int64, count int64)) *mRepositoryMockSubFromCart {
	if mmSubFromCart.mock.inspectFuncSubFromCart != nil {
		mmSubFromCart.mock.t.Fatalf("Inspect function is already set for RepositoryMock.SubFromCart")
	}

	mmSubFromCart.mock.inspectFuncSubFromCart = f

	return mmSubFromCart
}

// Return sets up results that will be returned by Repository.SubFromCart
func (mmSubFromCart *mRepositoryMockSubFromCart) Return(err error) *RepositoryMock {
	if mmSubFromCart.mock.funcSubFromCart != nil {
		mmSubFromCart.mock.t.Fatalf("RepositoryMock.SubFromCart mock is already set by Set")
	}

	if mmSubFromCart.defaultExpectation == nil {
		mmSubFromCart.defaultExpectation = &RepositoryMockSubFromCartExpectation{mock: mmSubFromCart.mock}
	}
	mmSubFromCart.defaultExpectation.results = &RepositoryMockSubFromCartResults{err}
	return mmSubFromCart.mock
}

// Set uses given function f to mock the Repository.SubFromCart method
func (mmSubFromCart *mRepositoryMockSubFromCart) Set(f func(ctx context.Context, userId int64, sku int64, count int64) (err error)) *RepositoryMock {
	if mmSubFromCart.defaultExpectation != nil {
		mmSubFromCart.mock.t.Fatalf("Default expectation is already set for the Repository.SubFromCart method")
	}

	if len(mmSubFromCart.expectations) > 0 {
		mmSubFromCart.mock.t.Fatalf("Some expectations are already set for the Repository.SubFromCart method")
	}

	mmSubFromCart.mock.funcSubFromCart = f
	return mmSubFromCart.mock
}

// When sets expectation for the Repository.SubFromCart which will trigger the result defined by the following
// Then helper
func (mmSubFromCart *mRepositoryMockSubFromCart) When(ctx context.Context, userId int64, sku int64, count int64) *RepositoryMockSubFromCartExpectation {
	if mmSubFromCart.mock.funcSubFromCart != nil {
		mmSubFromCart.mock.t.Fatalf("RepositoryMock.SubFromCart mock is already set by Set")
	}

	expectation := &RepositoryMockSubFromCartExpectation{
		mock:   mmSubFromCart.mock,
		params: &RepositoryMockSubFromCartParams{ctx, userId, sku, count},
	}
	mmSubFromCart.expectations = append(mmSubFromCart.expectations, expectation)
	return expectation
}

// Then sets up Repository.SubFromCart return parameters for the expectation previously defined by the When method
func (e *RepositoryMockSubFromCartExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockSubFromCartResults{err}
	return e.mock
}

// SubFromCart implements service.Repository
func (mmSubFromCart *RepositoryMock) SubFromCart(ctx context.Context, userId int64, sku int64, count int64) (err error) {
	mm_atomic.AddUint64(&mmSubFromCart.beforeSubFromCartCounter, 1)
	defer mm_atomic.AddUint64(&mmSubFromCart.afterSubFromCartCounter, 1)

	if mmSubFromCart.inspectFuncSubFromCart != nil {
		mmSubFromCart.inspectFuncSubFromCart(ctx, userId, sku, count)
	}

	mm_params := &RepositoryMockSubFromCartParams{ctx, userId, sku, count}

	// Record call args
	mmSubFromCart.SubFromCartMock.mutex.Lock()
	mmSubFromCart.SubFromCartMock.callArgs = append(mmSubFromCart.SubFromCartMock.callArgs, mm_params)
	mmSubFromCart.SubFromCartMock.mutex.Unlock()

	for _, e := range mmSubFromCart.SubFromCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSubFromCart.SubFromCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSubFromCart.SubFromCartMock.defaultExpectation.Counter, 1)
		mm_want := mmSubFromCart.SubFromCartMock.defaultExpectation.params
		mm_got := RepositoryMockSubFromCartParams{ctx, userId, sku, count}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSubFromCart.t.Errorf("RepositoryMock.SubFromCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSubFromCart.SubFromCartMock.defaultExpectation.results
		if mm_results == nil {
			mmSubFromCart.t.Fatal("No results are set for the RepositoryMock.SubFromCart")
		}
		return (*mm_results).err
	}
	if mmSubFromCart.funcSubFromCart != nil {
		return mmSubFromCart.funcSubFromCart(ctx, userId, sku, count)
	}
	mmSubFromCart.t.Fatalf("Unexpected call to RepositoryMock.SubFromCart. %v %v %v %v", ctx, userId, sku, count)
	return
}

// SubFromCartAfterCounter returns a count of finished RepositoryMock.SubFromCart invocations
func (mmSubFromCart *RepositoryMock) SubFromCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSubFromCart.afterSubFromCartCounter)
}

// SubFromCartBeforeCounter returns a count of RepositoryMock.SubFromCart invocations
func (mmSubFromCart *RepositoryMock) SubFromCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSubFromCart.beforeSubFromCartCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.SubFromCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSubFromCart *mRepositoryMockSubFromCart) Calls() []*RepositoryMockSubFromCartParams {
	mmSubFromCart.mutex.RLock()

	argCopy := make([]*RepositoryMockSubFromCartParams, len(mmSubFromCart.callArgs))
	copy(argCopy, mmSubFromCart.callArgs)

	mmSubFromCart.mutex.RUnlock()

	return argCopy
}

// MinimockSubFromCartDone returns true if the count of the SubFromCart invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockSubFromCartDone() bool {
	for _, e := range m.SubFromCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SubFromCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSubFromCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSubFromCart != nil && mm_atomic.LoadUint64(&m.afterSubFromCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockSubFromCartInspect logs each unmet expectation
func (m *RepositoryMock) MinimockSubFromCartInspect() {
	for _, e := range m.SubFromCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.SubFromCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SubFromCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSubFromCartCounter) < 1 {
		if m.SubFromCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.SubFromCart")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.SubFromCart with params: %#v", *m.SubFromCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSubFromCart != nil && mm_atomic.LoadUint64(&m.afterSubFromCartCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.SubFromCart")
	}
}

type mRepositoryMockTakeCountSkuUserFromCart struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockTakeCountSkuUserFromCartExpectation
	expectations       []*RepositoryMockTakeCountSkuUserFromCartExpectation

	callArgs []*RepositoryMockTakeCountSkuUserFromCartParams
	mutex    sync.RWMutex
}

// RepositoryMockTakeCountSkuUserFromCartExpectation specifies expectation struct of the Repository.TakeCountSkuUserFromCart
type RepositoryMockTakeCountSkuUserFromCartExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockTakeCountSkuUserFromCartParams
	results *RepositoryMockTakeCountSkuUserFromCartResults
	Counter uint64
}

// RepositoryMockTakeCountSkuUserFromCartParams contains parameters of the Repository.TakeCountSkuUserFromCart
type RepositoryMockTakeCountSkuUserFromCartParams struct {
	ctx    context.Context
	userId int64
	sku    int64
}

// RepositoryMockTakeCountSkuUserFromCartResults contains results of the Repository.TakeCountSkuUserFromCart
type RepositoryMockTakeCountSkuUserFromCartResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for Repository.TakeCountSkuUserFromCart
func (mmTakeCountSkuUserFromCart *mRepositoryMockTakeCountSkuUserFromCart) Expect(ctx context.Context, userId int64, sku int64) *mRepositoryMockTakeCountSkuUserFromCart {
	if mmTakeCountSkuUserFromCart.mock.funcTakeCountSkuUserFromCart != nil {
		mmTakeCountSkuUserFromCart.mock.t.Fatalf("RepositoryMock.TakeCountSkuUserFromCart mock is already set by Set")
	}

	if mmTakeCountSkuUserFromCart.defaultExpectation == nil {
		mmTakeCountSkuUserFromCart.defaultExpectation = &RepositoryMockTakeCountSkuUserFromCartExpectation{}
	}

	mmTakeCountSkuUserFromCart.defaultExpectation.params = &RepositoryMockTakeCountSkuUserFromCartParams{ctx, userId, sku}
	for _, e := range mmTakeCountSkuUserFromCart.expectations {
		if minimock.Equal(e.params, mmTakeCountSkuUserFromCart.defaultExpectation.params) {
			mmTakeCountSkuUserFromCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTakeCountSkuUserFromCart.defaultExpectation.params)
		}
	}

	return mmTakeCountSkuUserFromCart
}

// Inspect accepts an inspector function that has same arguments as the Repository.TakeCountSkuUserFromCart
func (mmTakeCountSkuUserFromCart *mRepositoryMockTakeCountSkuUserFromCart) Inspect(f func(ctx context.Context, userId int64, sku int64)) *mRepositoryMockTakeCountSkuUserFromCart {
	if mmTakeCountSkuUserFromCart.mock.inspectFuncTakeCountSkuUserFromCart != nil {
		mmTakeCountSkuUserFromCart.mock.t.Fatalf("Inspect function is already set for RepositoryMock.TakeCountSkuUserFromCart")
	}

	mmTakeCountSkuUserFromCart.mock.inspectFuncTakeCountSkuUserFromCart = f

	return mmTakeCountSkuUserFromCart
}

// Return sets up results that will be returned by Repository.TakeCountSkuUserFromCart
func (mmTakeCountSkuUserFromCart *mRepositoryMockTakeCountSkuUserFromCart) Return(i1 int64, err error) *RepositoryMock {
	if mmTakeCountSkuUserFromCart.mock.funcTakeCountSkuUserFromCart != nil {
		mmTakeCountSkuUserFromCart.mock.t.Fatalf("RepositoryMock.TakeCountSkuUserFromCart mock is already set by Set")
	}

	if mmTakeCountSkuUserFromCart.defaultExpectation == nil {
		mmTakeCountSkuUserFromCart.defaultExpectation = &RepositoryMockTakeCountSkuUserFromCartExpectation{mock: mmTakeCountSkuUserFromCart.mock}
	}
	mmTakeCountSkuUserFromCart.defaultExpectation.results = &RepositoryMockTakeCountSkuUserFromCartResults{i1, err}
	return mmTakeCountSkuUserFromCart.mock
}

// Set uses given function f to mock the Repository.TakeCountSkuUserFromCart method
func (mmTakeCountSkuUserFromCart *mRepositoryMockTakeCountSkuUserFromCart) Set(f func(ctx context.Context, userId int64, sku int64) (i1 int64, err error)) *RepositoryMock {
	if mmTakeCountSkuUserFromCart.defaultExpectation != nil {
		mmTakeCountSkuUserFromCart.mock.t.Fatalf("Default expectation is already set for the Repository.TakeCountSkuUserFromCart method")
	}

	if len(mmTakeCountSkuUserFromCart.expectations) > 0 {
		mmTakeCountSkuUserFromCart.mock.t.Fatalf("Some expectations are already set for the Repository.TakeCountSkuUserFromCart method")
	}

	mmTakeCountSkuUserFromCart.mock.funcTakeCountSkuUserFromCart = f
	return mmTakeCountSkuUserFromCart.mock
}

// When sets expectation for the Repository.TakeCountSkuUserFromCart which will trigger the result defined by the following
// Then helper
func (mmTakeCountSkuUserFromCart *mRepositoryMockTakeCountSkuUserFromCart) When(ctx context.Context, userId int64, sku int64) *RepositoryMockTakeCountSkuUserFromCartExpectation {
	if mmTakeCountSkuUserFromCart.mock.funcTakeCountSkuUserFromCart != nil {
		mmTakeCountSkuUserFromCart.mock.t.Fatalf("RepositoryMock.TakeCountSkuUserFromCart mock is already set by Set")
	}

	expectation := &RepositoryMockTakeCountSkuUserFromCartExpectation{
		mock:   mmTakeCountSkuUserFromCart.mock,
		params: &RepositoryMockTakeCountSkuUserFromCartParams{ctx, userId, sku},
	}
	mmTakeCountSkuUserFromCart.expectations = append(mmTakeCountSkuUserFromCart.expectations, expectation)
	return expectation
}

// Then sets up Repository.TakeCountSkuUserFromCart return parameters for the expectation previously defined by the When method
func (e *RepositoryMockTakeCountSkuUserFromCartExpectation) Then(i1 int64, err error) *RepositoryMock {
	e.results = &RepositoryMockTakeCountSkuUserFromCartResults{i1, err}
	return e.mock
}

// TakeCountSkuUserFromCart implements service.Repository
func (mmTakeCountSkuUserFromCart *RepositoryMock) TakeCountSkuUserFromCart(ctx context.Context, userId int64, sku int64) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmTakeCountSkuUserFromCart.beforeTakeCountSkuUserFromCartCounter, 1)
	defer mm_atomic.AddUint64(&mmTakeCountSkuUserFromCart.afterTakeCountSkuUserFromCartCounter, 1)

	if mmTakeCountSkuUserFromCart.inspectFuncTakeCountSkuUserFromCart != nil {
		mmTakeCountSkuUserFromCart.inspectFuncTakeCountSkuUserFromCart(ctx, userId, sku)
	}

	mm_params := &RepositoryMockTakeCountSkuUserFromCartParams{ctx, userId, sku}

	// Record call args
	mmTakeCountSkuUserFromCart.TakeCountSkuUserFromCartMock.mutex.Lock()
	mmTakeCountSkuUserFromCart.TakeCountSkuUserFromCartMock.callArgs = append(mmTakeCountSkuUserFromCart.TakeCountSkuUserFromCartMock.callArgs, mm_params)
	mmTakeCountSkuUserFromCart.TakeCountSkuUserFromCartMock.mutex.Unlock()

	for _, e := range mmTakeCountSkuUserFromCart.TakeCountSkuUserFromCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmTakeCountSkuUserFromCart.TakeCountSkuUserFromCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTakeCountSkuUserFromCart.TakeCountSkuUserFromCartMock.defaultExpectation.Counter, 1)
		mm_want := mmTakeCountSkuUserFromCart.TakeCountSkuUserFromCartMock.defaultExpectation.params
		mm_got := RepositoryMockTakeCountSkuUserFromCartParams{ctx, userId, sku}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTakeCountSkuUserFromCart.t.Errorf("RepositoryMock.TakeCountSkuUserFromCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTakeCountSkuUserFromCart.TakeCountSkuUserFromCartMock.defaultExpectation.results
		if mm_results == nil {
			mmTakeCountSkuUserFromCart.t.Fatal("No results are set for the RepositoryMock.TakeCountSkuUserFromCart")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmTakeCountSkuUserFromCart.funcTakeCountSkuUserFromCart != nil {
		return mmTakeCountSkuUserFromCart.funcTakeCountSkuUserFromCart(ctx, userId, sku)
	}
	mmTakeCountSkuUserFromCart.t.Fatalf("Unexpected call to RepositoryMock.TakeCountSkuUserFromCart. %v %v %v", ctx, userId, sku)
	return
}

// TakeCountSkuUserFromCartAfterCounter returns a count of finished RepositoryMock.TakeCountSkuUserFromCart invocations
func (mmTakeCountSkuUserFromCart *RepositoryMock) TakeCountSkuUserFromCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTakeCountSkuUserFromCart.afterTakeCountSkuUserFromCartCounter)
}

// TakeCountSkuUserFromCartBeforeCounter returns a count of RepositoryMock.TakeCountSkuUserFromCart invocations
func (mmTakeCountSkuUserFromCart *RepositoryMock) TakeCountSkuUserFromCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTakeCountSkuUserFromCart.beforeTakeCountSkuUserFromCartCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.TakeCountSkuUserFromCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTakeCountSkuUserFromCart *mRepositoryMockTakeCountSkuUserFromCart) Calls() []*RepositoryMockTakeCountSkuUserFromCartParams {
	mmTakeCountSkuUserFromCart.mutex.RLock()

	argCopy := make([]*RepositoryMockTakeCountSkuUserFromCartParams, len(mmTakeCountSkuUserFromCart.callArgs))
	copy(argCopy, mmTakeCountSkuUserFromCart.callArgs)

	mmTakeCountSkuUserFromCart.mutex.RUnlock()

	return argCopy
}

// MinimockTakeCountSkuUserFromCartDone returns true if the count of the TakeCountSkuUserFromCart invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockTakeCountSkuUserFromCartDone() bool {
	for _, e := range m.TakeCountSkuUserFromCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TakeCountSkuUserFromCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTakeCountSkuUserFromCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTakeCountSkuUserFromCart != nil && mm_atomic.LoadUint64(&m.afterTakeCountSkuUserFromCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockTakeCountSkuUserFromCartInspect logs each unmet expectation
func (m *RepositoryMock) MinimockTakeCountSkuUserFromCartInspect() {
	for _, e := range m.TakeCountSkuUserFromCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.TakeCountSkuUserFromCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TakeCountSkuUserFromCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTakeCountSkuUserFromCartCounter) < 1 {
		if m.TakeCountSkuUserFromCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.TakeCountSkuUserFromCart")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.TakeCountSkuUserFromCart with params: %#v", *m.TakeCountSkuUserFromCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTakeCountSkuUserFromCart != nil && mm_atomic.LoadUint64(&m.afterTakeCountSkuUserFromCartCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.TakeCountSkuUserFromCart")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddToCartInspect()

		m.MinimockDeleteAllFromCartInspect()

		m.MinimockDeleteFromCartInspect()

		m.MinimockListCartInspect()

		m.MinimockSubFromCartInspect()

		m.MinimockTakeCountSkuUserFromCartInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddToCartDone() &&
		m.MinimockDeleteAllFromCartDone() &&
		m.MinimockDeleteFromCartDone() &&
		m.MinimockListCartDone() &&
		m.MinimockSubFromCartDone() &&
		m.MinimockTakeCountSkuUserFromCartDone()
}
